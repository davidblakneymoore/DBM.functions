#' Generating Overall Plot Layout Matrices
#'
#' This function may be used to create plotting layout matrices when data are split up by more than one factor. The plotting layout matrices generated by this function create highly organized and ordered plot arrangements where plots are first grouped by levels of the first factor, then by levels of the sescond factor, then by levels of the third factor, and so on and so forth. The levels of the first factor are placed in separate columns. If a second factor is present, the levels of these second factor are placed in separate columns. If a third factor is present, these matrices containing the first and second factors are then themselves replicated and placed side by side (horizontally). If a fourth factor is present, these matrices containing the first, second, and third factors are then themselves replicated and placed on top of each other (vertically). If a fifth factor is present, these matrices containing the first, second, third, and fourth factors are then themselves replicated and placed side by side (horizontally). If a sixth factor is present, these matrices containing the first, second, third, fourth, and fifth factors are then themselves replicated and placed on top of each other (vertically). This process continues until all of the factors of interest have been accounted for. Factors must be balanced for this function to work - in other words, each level of each factor must appear with every level of every other factor.
#'
#' `Generating_Overall_Plot_Layout_Matrices` may be used to create plotting layout matrices when data are split up by more than one factor. The plotting layout matrices generated by this function create highly organized and ordered plot arrangements where plots are first grouped by levels of the first factor, then by levels of the sescond factor, then by levels of the third factor, and so on and so forth. The levels of the first factor are placed in separate columns. If a second factor is present, the levels of these second factor are placed in separate columns. If a third factor is present, these matrices containing the first and second factors are then themselves replicated and placed side by side (horizontally). If a fourth factor is present, these matrices containing the first, second, and third factors are then themselves replicated and placed on top of each other (vertically). If a fifth factor is present, these matrices containing the first, second, third, and fourth factors are then themselves replicated and placed side by side (horizontally). If a sixth factor is present, these matrices containing the first, second, third, fourth, and fifth factors are then themselves replicated and placed on top of each other (vertically). This process continues until all of the factors of interest have been accounted for. Factors must be balanced for this function to work - in other words, each level of each factor must appear with every level of every other factor.
#' @param Factors_to_Split_by a vector containing the names of the factors to include in the plotting layout matrix.
#' @param Data_Frame the data frame containing the names of all the levels of each factor.
#'
#' @return This function returns a plotting layout matrix for plotting all the different possible combinations of factor levels from a factorial experiment or study.
#'
#' @author David B. Moore (\email{davidblakneymoore@@gmail.com})
#'
#' @examples
#' set.seed(142)
#' (Data_Frame <- data.frame(Factor_1 = rep(1:2, each = 12), Factor_2 = rep(LETTERS[1:4], each = 3, length.out = 24), Factor_3 = rep(letters[1:3], length.out = 24)))
#' (Factors_to_Split_by <- paste("Factor", seq_len(3), sep = "_"))
#' Splitting_the_Data_Frame <- function (Data_Frame, Factors_to_Split_by) {
#'   if (is.data.frame(Data_Frame)) {
#'     split(Data_Frame, Data_Frame[Factors_to_Split_by])
#'   } else {
#'     lapply(Data_Frame, Splitting_the_Data_Frame, Factors_to_Split_by = Factors_to_Split_by)
#'   }
#' }
#' Split_Data <- Splitting_the_Data_Frame(Data_Frame, Factors_to_Split_by)
#' Number_of_Rows_in_Each_Data_Frame <- 5
#' Split_Data <- lapply(Split_Data, function (x) {
#'   y <- do.call("rbind", lapply(seq_len(Number_of_Rows_in_Each_Data_Frame), function (y) {
#'     x
#'   }))
#'   y$Column_1 <- seq_len(Number_of_Rows_in_Each_Data_Frame)
#'   y$Column_2 <- rnorm(Number_of_Rows_in_Each_Data_Frame)
#'   y
#' })
#' Overall_Layout_Matrix <- Generating_Overall_Plot_Layout_Matrices(Factors_to_Split_by, Data_Frame)
#' layout(Overall_Layout_Matrix)
#' lapply(Split_Data, function (x) {
#'   plot(x$Column_2 ~ x$Column_1, pch = 19, main = paste0("Factor 1: ", unique(x$Factor_1), "; Factor 2: ", unique(x$Factor_2), "; Factor 3: ", unique(x$Factor_3)), xlab = "Column 1", ylab = "Column 2")
#' })
#'
#' @export
Generating_Overall_Plot_Layout_Matrices <- function (Factors_to_Split_by, Data_Frame) {
  if (is.null(Factors_to_Split_by)) {
    stop ("The 'Factors_to_Split_by' argument must be present.")
  }
  if (any(is.na(Factors_to_Split_by))) {
    stop ("The 'Factors_to_Split_by' argument must not contain any missing values.")
  }
  if (is.list(Factors_to_Split_by)) {
    stop ("The 'Factors_to_Split_by' argument must not be a list.")
  }
  if (!is.vector(Factors_to_Split_by)) {
    stop ("The 'Factors_to_Split_by' argument must be a vector.")
  }
  if (!is.character(Factors_to_Split_by)) {
    stop ("The 'Factors_to_Split_by' argument must be of class 'character'.")
  }
  if (!is.data.frame(Data_Frame)) {
    stop ("The 'Data_Frame' argument must be of class 'data.frame'.")
  }
  if (!all(Factors_to_Split_by %in% colnames(Data_Frame))) {
    stop ("All of the elements of the 'Factors_to_Split_by' must also be column names in the 'Data_Frame' data frame.")
  }
  if (Reduce(`*`, sapply(Factors_to_Split_by, function (x) {
    length(unique(Data_Frame[, which(colnames(Data_Frame) == x)]))
  })) != length(unique(do.call("interaction", lapply(Factors_to_Split_by, function (x) {
    Data_Frame[, which(colnames(Data_Frame) == x)]
  }))))) {
    stop ("The factors in the 'Factors_to_Split_by' argument must be balanced in the 'Data_Frame' data frame - all of the levels of each factor must appear with all of the levels of each of the other factors.")
  }
  for (i in seq_along(Factors_to_Split_by)) {
    if (i == 1) {
      Layout_Matrix <- matrix(seq_along(unique(Data_Frame[, which(colnames(Data_Frame) == Factors_to_Split_by[i])])), nrow = 1)
    } else if (i > 1) {
      if ((i %% 2) == 1) {
        Layout_Matrix <- do.call("cbind", lapply(seq_along(unique(Data_Frame[, which(colnames(Data_Frame) == Factors_to_Split_by[i])])), function (x) {
          Layout_Matrix + (max(Layout_Matrix) * (x - 1))
        }))
      } else if ((i %% 2) == 0) {
        Layout_Matrix <- do.call("rbind", lapply(seq_along(unique(Data_Frame[, which(colnames(Data_Frame) == Factors_to_Split_by[i])])), function (x) {
          Layout_Matrix + (max(Layout_Matrix) * (x - 1))
        }))
      }
    }
  }
  Layout_Matrix
}
