% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes.R
\name{Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes}
\alias{Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes}
\title{Generating Optimal Axis Limits for Figures With Text Boxes}
\usage{
Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes(
  Points_Horizontal_Axis_Coordinates,
  Points_Vertical_Axis_Coordinates,
  Texts,
  Texts_Horizontal_Axis_Coordinates,
  Texts_Vertical_Axis_Coordinates,
  Character_Expansion = 1,
  Spacing_Constant = 1,
  Text_Shifting_Method = "Using_Vector_Directions_With_Rightward_Tendancy",
  Should_Text_Box_Polygons_Shade_out_Points = FALSE
)
}
\arguments{
\item{Points_Horizontal_Axis_Coordinates}{the numeric variables comprising the coordinates from the first ordination axis (which will become the horizontal axis).}

\item{Points_Vertical_Axis_Coordinates}{the numeric variables comprising the coordinates from the second ordination axis (which will become the vertical axis).}

\item{Texts}{the vector of loadings names.}

\item{Texts_Horizontal_Axis_Coordinates}{the values you wish to align across the vertical axes. The default for this argument is a vector of \code{0}s. This argument must be a numeric vector and it must contain the same number of elements that there are variables being aligned.}

\item{Texts_Vertical_Axis_Coordinates}{the weights assigned to each variable. To prevent certain variables from being crowded near the top or the bottom of the plot, a greater weight can be assigned to these variables, which ensures that these variables will take up more of the plotting region (at the expense of other variables, of course). The default for this argument is to assign all the variables the same weight. This argument must be a numeric vector, all the entries must be finite and nonnegative, and it must contain the same number of elements as there are variables being aligned.}

\item{Character_Expansion}{the relative sizes of the names of the loadings labels. This argument is passed to the \code{"cex"} argument of all the relevant graphing functions. The default is \code{1}. This argument must be a nonnegative number.}

\item{Spacing_Constant}{the relative amount of space between the loadings labels and the tips of the loadings vectors. The default is \code{1} (which corresponds to the size of a gap between two lines in a text box). Larger numbers for this argument lead to larger spacing. This argument must be a nonnegative number. Horizontal and vertical spacing is equal as all calculations are done in inches and take into account the dimensions of the plotting region.}

\item{Text_Shifting_Method}{the method for shifting text boxes away from loading vector tips. The \code{"None"} method centers text boxes at the tip of the loading vectors. The \code{"Only_Horizontally_With_Leftward_Tendancy"} method shifts text boxes horizontally away from loading vector tips, but if there are no horizontal components to loading vectors, shifts to the left are performed. The \code{"Only_Horizontally_With_Rightward_Tendancy"} method shifts text boxes horizontally away from loading vector tips, but if there are no horizontal components to loading vectors, shifts to the right are performed. The \code{"Mainly_Horizontally_With_Leftward_Tendancy"} method shifts text boxes horizontally away from loading vector tips. If there are no horizontal components to loading vectors, vertical shifts are performed if there are vertical components, and shifts to the left are performed if there are no vertical components. The \code{"Mainly_Horizontally_With_Rightward_Tendancy"} method shifts text boxes horizontally away from loading vector tips. If there are no horizontal components to loading vectors, vertical shifts are performed if there are vertical components, and shifts to the right are performed if there are no vertical components. The \code{"Only_Vertically_With_Upward_Tendancy"} method shifts text boxes vertically away from loading vector tips, but if there are no vertical components to loading vectors, shifts up are performed. The \code{"Only_Vertically_With_Downward_Tendancy"} method shifts text boxes vertically away from loading vector tips, but if there are no vertical components to loading vectors, shifts down are performed. The \code{"Mainly_Vertically_With_Upward_Tendancy"} method shifts text boxes vertically away from loading vector tips. If there are no vertical components to loading vectors, horizontal shifts are performed if there are horizontal components, and shifts up are performed if there are no horizontal components. The \code{"Mainly_Vertically_With_Downward_Tendancy"} method shifts text boxes vertically away from loading vector tips. If there are no vertical components to loading vectors, horizontal shifts are performed if there are horizontal components, and shifts down are performed if there are no horizontal components. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_45_Degree_Angles_With_Leftward_Tendancy"} method places text box corners at the tips of the loading vectors at an angle of 45 ˚. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted to the left. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_45_Degree_Angles_With_Upward_Tendancy"} method places text box corners at the tips of the loading vectors at an angle of 45 ˚. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted up. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_45_Degree_Angles_With_Rightward_Tendancy"} method places text box corners at the tips of the loading vectors at an angle of 45 ˚. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted to the right. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_45_Degree_Angles_With_Downward_Tendancy"} method places text box corners at the tips of the loading vectors at an angle of 45 ˚. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted down. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_the_Same_Angles_as_the_Associated_Vectors_With_Leftward_Tendancy"} method places text box corners at the tips of the loading vectors at the same angle as the loading vectors. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted to the left. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_the_Same_Angles_as_the_Associated_Vectors_With_Upward_Tendancy"} method places text box corners at the tips of the loading vectors at the same angle as the loading vectors. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted up. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_the_Same_Angles_as_the_Associated_Vectors_With_Rightward_Tendancy"} method places text box corners at the tips of the loading vectors at the same angle as the loading vectors. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted to the right. The \code{"Mainly_Diagonally_Using_Text_Box_Corners_at_the_Same_Angles_as_the_Associated_Vectors_With_Downward_Tendancy"} method places text box corners at the tips of the loading vectors at the same angle as the loading vectors. For vectors with no horizontal vector components, text boxes are shifted vertically; for vectors with no vertical vector components, text boxes are shifted horizontally. For vectors with neither vertical nor horizontal components, text boxes are shifted down. The \code{"Using_Vector_Directions_With_Leftward_Tendancy"} method places text box centers in lne with vectors such that the minimum spacing between text boxes and vector tips is the spacing set by the user. For vectors with neither vertical nor horizontal components, text boxes are shifted to the left. The \code{"Using_Vector_Directions_With_Upward_Tendancy"} method places text box centers in lne with vectors such that the minimum spacing between text boxes and vector tips is the spacing set by the user. For vectors with neither vertical nor horizontal components, text boxes are shifted up. The \code{"Using_Vector_Directions_With_Rightward_Tendancy"} method places text box centers in lne with vectors such that the minimum spacing between text boxes and vector tips is the spacing set by the user. For vectors with neither vertical nor horizontal components, text boxes are shifted to the right. The \code{"Using_Vector_Directions_With_Downward_Tendancy"} method places text box centers in lne with vectors such that the minimum spacing between text boxes and vector tips is the spacing set by the user. For vectors with neither vertical nor horizontal components, text boxes are shifted down. The default is \code{"Using_Vector_Directions_With_Rightward_Tendancy"}.}

\item{Should_Text_Box_Polygons_Shade_out_Points}{A logical indicator which specifies whether text boxes are to be shaded prior to adding the text. If shading is to occur, a small additional amount of space is left around the outside of the plotting regions so that the shaded areas do not get cut off by the edge of the plot. The default is \code{FALSE}.}
}
\value{
This function returns the new axis limits to ensure all points and loadings labels are visible in the plotting region, and it also returns the coordinates for the loadings labels (taking into account the size of these labels). Finally, if text boxes are to be shaded, it will also return the coordinates of the corners of the text boxes.
}
\description{
This function may be used to generate axis limits for plots when both text and points (or lines) are present. It was developed specifically for ordinations (such as \href{https://en.wikipedia.org/wiki/Principal_component_analysis}{principal component analysis} or \href{https://en.wikipedia.org/wiki/Multidimensional_scaling#Non-metric_multidimensional_scaling_(NMDS)}{non-metric multidimensional scaling}) when data points are plotted alongside loadings vectors and when these loadings vectors are identified with text on the plot.
}
\details{
Use this function only when you've already got the plotting window's desired dimensions set. Don't use the function, resize the plotting window, and then use the output of the function to plot - it won't work. The function uses the current size of the plotting region in its calculations.

Unfortunately, this function cannot handle formatted text (such as bold, italicized, or underlined text) at this time.

Also, unfortunately, this function cannot handle figures with multiple plots because the function turns off the null device and creates a lot of plots internally to generate the output.

\code{Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes} may be used to generate axis limits for plots when both text and points (or lines) are present. It was developed specifically for ordinations (such as \href{https://en.wikipedia.org/wiki/Principal_component_analysis}{principal component analysis} or \href{https://en.wikipedia.org/wiki/Multidimensional_scaling#Non-metric_multidimensional_scaling_(NMDS)}{non-metric multidimensional scaling}) when data points are plotted alongside loadings vectors and when these loadings vectors are identified with text on the plot.
}
\examples{
set.seed(121)
Number_of_Data_Points <- 75
Ordination_Data <- data.frame(Ordination_Axis_1_Coordinates = rnorm(Number_of_Data_Points), Ordination_Axis_2_Coordinates = rnorm(Number_of_Data_Points))
Loadings <- data.frame(Variable = paste("Variable", seq_len(5), sep = "_"), Ordination_Axis_1_Coordinate = c(-0.1, -0.3, 1.2, 3.3, 1.1), Ordination_Axis_2_Coordinate = c(-1.1, -0.1, 0.5, -2.2, 1.7))
plot(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, type = "n", xlab = "Ordination Axis 1", ylab = "Ordination Axis 2", main = "Example Figure 1:\nOnly Points Are Considered When Determining Axis Limits")
points(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, pch = 19, col = 2)
arrows(rep(0, nrow(Loadings)), rep(0, nrow(Loadings)), Loadings$Ordination_Axis_1_Coordinate, Loadings$Ordination_Axis_2_Coordinate, length = 0.1)
plot(c(Ordination_Data$Ordination_Axis_1_Coordinates, Loadings$Ordination_Axis_1_Coordinate), c(Ordination_Data$Ordination_Axis_2_Coordinates, Loadings$Ordination_Axis_2_Coordinate), type = "n", xlab = "Ordination Axis 1", ylab = "Ordination Axis 2", main = "Example Figure 2:\nPoints and Loading Vectors Are Considered When Determining Axis Limits")
points(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, pch = 19, col = 2)
arrows(rep(0, nrow(Loadings)), rep(0, nrow(Loadings)), Loadings$Ordination_Axis_1_Coordinate, Loadings$Ordination_Axis_2_Coordinate, length = 0.1)
(Output_1 <- Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, Loadings$Variable, Loadings$Ordination_Axis_1_Coordinate, Loadings$Ordination_Axis_2_Coordinate, Character_Expansion = 1.125, Spacing_Constant = 0.875))
plot(0, type = "n", xlab = "Ordination Axis 1", ylab = "Ordination Axis 2", main = "Example Figure 3:\nOptimal Axis Limits Are Generated to Include Loading Vector Variable Names", xlim = Output_1$Axis_Limits$Horizontal_Axis_Limits, ylim = Output_1$Axis_Limits$Vertical_Axis_Limits)
points(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, pch = 19, col = 2)
arrows(rep(0, nrow(Loadings)), rep(0, nrow(Loadings)), Loadings$Ordination_Axis_1_Coordinate, Loadings$Ordination_Axis_2_Coordinate, length = 0.1)
text(Output_1$New_Texts_Axis_Coordinates$New_Texts_Horizontal_Axis_Coordinate, Output_1$New_Texts_Axis_Coordinates$New_Texts_Vertical_Axis_Coordinate, Output_1$New_Texts_Axis_Coordinates$Text, cex = 1.125)
(Output_2 <- Generating_Optimal_Axis_Limits_for_Figures_With_Text_Boxes(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, Loadings$Variable, Loadings$Ordination_Axis_1_Coordinate, Loadings$Ordination_Axis_2_Coordinate, Character_Expansion = 1.125, Spacing_Constant = 0.875, Should_Text_Box_Polygons_Shade_out_Points = TRUE))
plot(0, type = "n", xlab = "Ordination Axis 1", ylab = "Ordination Axis 2", main = "Example Figure 4:\nOptimal Axis Limits Are Generated to Include Loading Vector Variable Names With Background Shading", xlim = Output_2$Axis_Limits$Horizontal_Axis_Limits, ylim = Output_2$Axis_Limits$Vertical_Axis_Limits)
points(Ordination_Data$Ordination_Axis_1_Coordinates, Ordination_Data$Ordination_Axis_2_Coordinates, pch = 19, col = 2)
lapply(split(Output_2$Text_Box_Corner_Data_Frame, Output_2$Text_Box_Corner_Data_Frame$Text), function (x) {
  polygon(x = c(x$Horizontal_Coordinates, x$Horizontal_Coordinates[1]), y = c(x$Vertical_Coordinates, x$Vertical_Coordinates[1]), col = "grey90", border = NA)
})
arrows(rep(0, nrow(Loadings)), rep(0, nrow(Loadings)), Loadings$Ordination_Axis_1_Coordinate, Loadings$Ordination_Axis_2_Coordinate, length = 0.1)
text(Output_2$New_Texts_Axis_Coordinates$New_Texts_Horizontal_Axis_Coordinate, Output_2$New_Texts_Axis_Coordinates$New_Texts_Vertical_Axis_Coordinate, Output_2$New_Texts_Axis_Coordinates$Text, cex = 1.125)

}
\author{
David B. Moore (\email{davidblakneymoore@gmail.com})
}
