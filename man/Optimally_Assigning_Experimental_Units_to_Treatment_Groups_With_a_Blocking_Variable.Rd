% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/Optimally_Assigning_Experimental_Units_to_Treatment_Groups_With_a_Blocking_Variable.R
\name{Optimally_Assigning_Experimental_Units_to_Treatment_Groups_With_a_Blocking_Variable}
\alias{Optimally_Assigning_Experimental_Units_to_Treatment_Groups_With_a_Blocking_Variable}
\title{Optimally Assigning Experimental Units to Treatment Groups With a Blocking Variable}
\usage{
Optimally_Assigning_Experimental_Units_to_Treatment_Groups_With_a_Blocking_Variable(
  ...,
  Identifiers,
  Blocking_Variable,
  Data_Frame = NULL,
  Number_of_Treatment_Groups,
  Number_of_Experimental_Units_From_Each_Block_in_Each_Treatment_Group,
  Variable_Weights = rep(1, ifelse(missing(Data_Frame), length(list(...)),
    ncol(Data_Frame[, c(which(colnames(Data_Frame) \%in\% sapply(match.call(expand.dots =
    FALSE)$..., deparse)))]))),
  Moment_Weighing_Method = c("Exponential (2 Base)", "Exponential (Golden Ratio Base)",
    "Ordinal", "Exponential (Euler's Number Base)", "None", "Custom Weights"),
  Custom_Moment_Weights = NULL
)
}
\arguments{
\item{...}{the variables you measured on your experimental units that you wish to keep as consistent as possible across treatment groups.}

\item{Identifiers}{the names of the experimental units.}

\item{Blocking_Variable}{the names of the blocks. If there is more than one blocking variable, please use R's \code{interaction()} function to combine the different blocking variables into one variable before using the function.}

\item{Data_Frame}{an optional argument to provide if all the \code{...} arguments, the \code{Identifiers} argument, and the \code{Blocking_Variable} argument all come from the same data frame and to prevent typing the data frame name multiple times.}

\item{Number_of_Treatment_Groups}{the number of treatment groups in the study or experiment.}

\item{Number_of_Experimental_Units_From_Each_Block_in_Each_Treatment_Group}{the number of experimental units to be assigned to each treatment group in each block in the study or experiment. This function only handles balanced designs where each treatment group contains the same number of experimental units from each block.}

\item{Variable_Weights}{the relative weights (importances) of each of the \code{...} arguments (variables) in the calculations. Variables that are weighed more heavily will be held more consistent across treatment groups than variables that are weighed less heavily. By default, each variable is weighed equally.}

\item{Moment_Weighing_Method}{the method of weighing mathematical moments. Almost all of the built-in methods weigh moments sequentially, with lower-order moments being weighed more heavily than higher-order moments are weighed. This function calculates moments up to the order of the number of experimental units in each treatment group (as specified in the \code{Number_of_Experimental_Units_in_Each_Treatment_Group} argument). The default method weighs each moment more heavily than the subsequent moment by a factor of the Golden Ratio (\code{((1 + sqrt(5)) / 2)}), with lower-order moments being weighed the most heavily and higher-order moments being weighed the least heavily.}

\item{Custom_Moment_Weights}{the weights of each of the mathematical moments (in order from the lowest-order moment to the highest-order moment) if and only if \code{"Custom Weights"} is specified for the \code{Moment_Weighing_Method} argument.}
}
\value{
This function returns optimal treatment group assignments (for cases when there is a blocking variable). Since experimental units are assigned to treatment groups separately (in a completely independent fashion) by block, each of the main list elements of the function's output correspond to a different block.
}
\description{
This function may be used to assign experimental units to treatment groups (for cases when there is a blocking variable) when you wish to ensure that treatment groups are as balanced as possible for a particular set of experimental units' variables.
}
\details{
\code{Optimally_Assigning_Experimental_Units_to_Treatment_Groups_With_a_Blocking_Variable} may be used when setting out a study or an experiment (for cases when there is a blocking variable) to optimize the assignments of experimental units to treatment groups. Although randomization is typically used to assign treatments to experimental units, sometimes, randomization may unintentionally create treatment groups that are not balanced. For example, perhaps after randomizing, certain treatment groups end up being comprised of experimental units that are bigger or heavier or hotter or shadier or wetter than the experimental units in the other treatment groups are. This undesirable effect may be avoided by using this function, which ensures that means and possibly other higher-order mathematical moments (such as variances, skewnesses, and kurtoses) for a particular set of experimental units' variables you've already measured are as similar as possible across treatment groups.

This function was designed for studies or experiments that are blocked - it ensures that balance is maintained across treatment groups within blocks. One of the advantages of blocked studies or experiments is that blocks may account for some of the overall variability in the data (sample processing should be done, and measurements should be taken, by block), and if a problem arises with a block (or multiple blocks), this block (or these blocks) may be dropped from the study without losing the balanced structure of the study or experiment. By ensuring that treatment groups are balanced within blocks, this function ensures that if a block (or multiple blocks) must be dropped from the study or experiment, the remaining blocks will still be as balanced as possible since each block was balanced independently.

Please note that randomization is still a very useful technique - if you suspect that you did not measure a suite of experimental unit variables that may have a strong influence on the response variables in your study or experiment, randomization may be a better method than this optimization method.

Also, please note that this function may take an extremely long time to run when there are many potential experimental units!
}
\examples{
# Generate Some Made-up Data
set.seed(2024)
Data_Frame <- data.frame(Tree_Identifier = paste("Tree", seq_len(40), sep = "_"), Block = rep(1:4, each = 10, length.out = 40), Diameter_at_Breast_Height = round(runif(40, 25, 50), 1), Height = round(runif(40, 30, 40), 1), Crown_Class = sample(c("Dominant", "Codominant", "Intermediate", "Overtopped"), 40, replace = TRUE), Significant_Defect_Present = sample(c("Yes", "No"), 40, replace = TRUE, prob = c(0.05, 0.95)))

# Determine Which Combinations Are Optimal for Assigning Experimental Units to Treatment Groups
Optimal_Group_Assignments_by_Block <- DBM.functions::Optimally_Assigning_Experimental_Units_to_Treatment_Groups_With_a_Blocking_Variable(Diameter_at_Breast_Height, Height, Crown_Class, Significant_Defect_Present, Identifiers = Tree_Identifier, Blocking_Variable = Block, Data_Frame = Data_Frame, Number_of_Treatment_Groups = 4, Number_of_Experimental_Units_From_Each_Block_in_Each_Treatment_Group = 2)
(The_Best_3_Grouping_Combinations_for_Each_Block <- lapply(Optimal_Group_Assignments_by_Block, `[`, seq_len(3)))

}
\author{
David B. Moore (\email{davidblakneymoore@gmail.com})
}
